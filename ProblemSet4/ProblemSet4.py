# -*- coding: utf-8 -*-
"""
Created on Sat Nov 15 12:07:24 2025

@author: Eryka
"""

import numpy as np
from numpy import random
import pandas as pd 
import matplotlib.pyplot as plt 
import seaborn as sns
from scipy.optimize import curve_fit

#Question 1 
PID = random.choice(range(1,41), size = 40, replace = False) #using NumPy to generate participant IDs, 1 - 40 by one step (so going 1,2,3,4). Other methods allowed for repeating of numbers (aka there was multiple number 3s). Because a PID should be unique, I use random choice and gave it a range to pick from, with 40 numbers, and replace ensures that each value is unique. (source geeksforgeeks.org)
PID.sort() #making sure that each ID is in order of 1 - 40 

ConTrials =[] #Empty lists to append to in the function, these will also be used to build the data frame later 
InConTrials = []

def ConRT(PID): #Function to create the congruent RTs per participant 
    for i in range(40): #40 participants, so this will loop 40 times to get all 40 participants.
        Congruent = random.normal(520, 70, 50) #Generating RTs with a mean of 520, SD of 70, and the 50 represents the 50 trials . This is to ensure there was 50 values within each participant's cell. 
        ConTrials.append(Congruent) #append to the list to make this a global variable that I can add to a dataframe later 
        
ConRT(PID)

def InConRT(PID): #Function to create the incongruent RTs per participant 
    for i in range(40): #41 to represent number of participants (same as in conRT function)
        Incongruent = random.normal (610, 70, 50) #Generating RTs with a mean of 610, a standard deviation of 70, and 50 represents the number of trials each participant completed. 
        InConTrials.append(Incongruent)

InConRT(PID)

TempConDF = pd.DataFrame() #Creating a temporary data frame to put the participant ID in and the congruent trial's reaction times 
TempConDF['Participants'] = PID #adding participant ID
TempConDF['Condition'] = 'Congruent' #adding the condition type
TempConDF['RT'] = ConTrials #adding the actual RT data generated by the conRT function

TempInconDF = pd.DataFrame() #Temporary data frame to put the PID and the condition type for the incongruent condition
TempInconDF['Participants'] = PID #entering the participant ID
TempInconDF['Condition'] = 'Incongruent' #entering the condition type 
TempInconDF['RT'] = InConTrials #entering the RT data for the incongruent condition generated by the inconRT function

FinalData = pd.concat([TempConDF, TempInconDF], ignore_index = True) #This is to stack the two temporary congruent and incongruent data frames ontop of each other to ensure all the columns aligned properly. 
FinalData = FinalData.explode('RT') #Exploding means expanding the values nested in each cell, each participant cell had 50 values in it so this is to put each of those values in their own column while keeping participant ID and the condition type. 

NoiseNum = [] #this is to keep track of the value of the noise that was generated so I could check my work and make sure the function to add noise was actually added. 
def AddNoise(FinalData): #Function to add noise to the RT data. 
    for i in range(len(FinalData['RT'])): #For the range of all the reaction time data
        noise = np.random.uniform(low = -20,high = 20, size = None) #generating noise +/- 20ms randomly
        NoiseNum.append(noise)
    FinalData['RT'] = FinalData['RT'] + NoiseNum #adding the noise generated to the RT data 

AddNoise(FinalData)

def Display10(FinalData): #Function to display the first ten rows and the descriptive statistics 
    print(FinalData.head(10)) #Displays the top ten rows (that's what the head portion of this means)
    print(FinalData.describe()) #Displays the descriptive statistics of the data frame. 
    
Display10(FinalData)

#Question 2

def removeOutliers(FinalData): #Function to remove outliers 
    mask1 = FinalData['RT'] >150 #This is the upper limit of the range. I think this is too high to actually remove the lower outliers as none the values are removed. It does work when replaced with other values like 300. 
    mask2 = FinalData['RT'] <1500 #This is the lower limit of the range to remove. I think this is too high to catch the upper outliers. This function does work when replaced with smaller values. 
    ItemsRM = mask1.sum().sum() #This is to calculate the amount of RTs that were removed from the data using the upper range 
    ItemsRM2 = mask2.sum().sum() #This is to calculate the amount of RTs that were removed based on the lower range number 
    print(ItemsRM, ItemsRM2) #This prints to the terminal the amount of RTs that were removed in the outleir removing process. 
    
removeOutliers(FinalData)
by_participant = FinalData.groupby(['Participants', 'Condition'])['RT'].mean().reset_index() #This function creates a new data frame (by_participant). The .groupby function organizes the data by participant and condition. It collapses all the RTs for each participant to one value, this value is the mean of all the RTs for that participant. 

#Question 3

def CalcRTMean(by_participant): #This calculcates the mean RT
    Conmask = by_participant[by_participant['Condition'] == 'Congruent']['RT'].mean() #This calculates the mean RT for the congruent condition as a whole
    print(Conmask) #print number removed to the terminal
    Inconmask = by_participant[by_participant['Condition'] == 'Incongruent']['RT'].mean() #This calcualtes the mean RT for the incongruent condition as a whole 
    print(Inconmask) #print number removed to the terminal 

CalcRTMean(by_participant) #call function

by_participant['Accuracy'] = '' #creating an empty column called accuracy in the by_participant dataframe 
acc = [] #appending the value of 1 or 0 based on the probability (80% of the time there is a one)

def Accuracy(by_participant): #Loop to append to the empty accuracy column 
    for i in range(80): #The number of values in the data frame, so it knows to generate 81 values for each row of the data frame. 
        percent = random.random() #choosing a random value between 0 and 1, think of this as the percentage with 1 representing 100% 
        if percent < 0.8: #If the value is smaller than 0.8 (or 80%), 1 will be appended to the acc list 
            acc.append(1)
        elif percent > 0.8: #If the value is biggerr than 0.8 (or 80%), 0 will be appended to the acc list 
           acc.append(0)
    
Accuracy(by_participant)
by_participant['Accuracy'] = acc #I could not figure out how to append right to the data frame in the above loop. That's why it was appended to a list with the same amount of values as there was in the dataframe. This function adds that list to the empty accuracy column that was created. 
accRT = by_participant [by_participant['Accuracy'] == '1']['RT'].mean() #This calculates the mean RT for only the trials marked as accurate. 

#Question 4 

#Warning for running the plots, once you run everything, it'll create a weird plot with everything on top of each other. Running each plot individually shows you that all of them work.

def PlotHist(by_participant): #Function to generate two histograms, one represents the congruent RT and the other represents the incongruent RT. 
    plots = plt.figure(num = 2, figsize =(5.0,4.0)) #Generate a figure with two subplots 
    plots.suptitle('Reaction time by Condition') #Label the figure with what I'm plotting 
    axes1 = plots.add_subplot(1,2,1) #create the first subplot, indicate the it is one line, two plots, and the first plot in the line 
    axes2 = plots.add_subplot(1,2,2) #create the second subplot, indicates that it is one line, two plots, and the second plot in the line 
    consorted = by_participant.loc[by_participant['Condition'] == 'Congruent']['RT'] #locate the congruent condition's reaction times 
    inconsorted = by_participant.loc[by_participant['Condition'] == 'Incongruent']['RT'] #locate the incongruent condition's reaction times 
    axes1.set_xlabel ('Congruent') #setting the label for the subplot on the x-axis 
    axes2.set_xlabel ('Incongruent') #setting the label for the second subplot on the x-axis 
    axes1.hist(consorted) #create the histogram using the located congruent RTs
    axes2.hist(inconsorted) #create the second subplot histogram using the located incongruent RTs
     
PlotHist(by_participant) #call function

def PlotBar(by_participant): #Plot a bar graph using the dataframe 
    consorted = by_participant[by_participant['Condition'] == 'Congruent']['RT'].mean() #locate the incongruent condition's RTs 
    inconsorted = by_participant[by_participant['Condition'] == 'Incongruent']['RT'].mean()
    condition = ['Congruent', 'Incongruent'] #Creating a list of conditions to use as the x - axis data
    values = [consorted, inconsorted] #this is the list of means for each condition to be used as the plotted data 
    colors = ['green','red'] #This is to change the colour of each bar, the green is the congruent bar and the red is the incongruent bar. This needed to be a list with the colours in the intended order to then pass it into the colour part of the bar function. 
    SD_con = by_participant[by_participant['Condition'] == 'Congruent']['RT'].std() #Calculate the standard deviation of the congruent condition for the standard error 
    SD_incon = by_participant[by_participant['Condition'] == 'Incongruent']['RT'].std() #Calculate the standard deviatioon of the incongruent condition for the standard error 
    SE_con = SD_con/np.sqrt(40) #Calculate the standard error for the congruent condition
    SE_incon = SD_incon/np.sqrt(40) #Calculate the standard error for incongruent condition
    plt.bar(condition, values, color = colors, yerr = [SE_con, SE_incon]) #create a bar graph using the conditions on the x axis, the RT on the y axis, set the colour for each bar based on the list I created, and put the error bars 
    plt.title('Reaction Time by Condition') #This is the title of the whole graph
    plt.ylabel('Mean Reaction Time') #Y axis label
    plt.xlabel('Condition') #x axis label
    
PlotBar(by_participant) #call the function

#Question 5 
#Looked at class notes and the documentation for this plot 
def violinplot (by_participant): #create a violin plot using seaborn
    sns.violinplot(data = by_participant, x = 'Condition', y = 'RT') #Creating the plot using the by_participants dataframe. X is the condition, y is the RT
    
violinplot(by_participant) #call function

#looked at the class notes and the documentation in seaplot for this one 
def lineplot (by_participant): #create a line plot 
    sns.lineplot(data = by_participant, x = 'Condition', y = 'RT', hue = 'Participants') #creating a line plot using the by_participant data frame. X represents the condition, y represents the RT, hue is set to participants, it grouped participants in groups of eight and each group has a specific colour. 
    
lineplot(by_participant) #call the function 

#Question 6 

#needed a lot of help with this one, used chatgpt to help with this one. 
loads = np.array([1, 2, 3, 4, 5, 6]) #set up x data 
k = np.array([0.9000, 1.8000, 2.7000, 3.5000, 3.1966, 3.7939]) #set up y data 


def model1fit(x, a,b, k_break): #def function to put the line's equation in 
    y = [] #to append the formula to in order to use in the plotting of the line 
    for load in x: #cycle through the x data 
        if load <= k_break:
            y.append(a * load + b)# K is increasing with load
        else:
            y.append(a * k_break + b) # K stays constant
    return np.array(y) #return it as an array because I kept getting issues plotting the data if it wasn't stored in an array. 


def model2fit (x, A, B,C): #another function to put the second model's line equation in 
    return A * (1 - np.exp(-B * x)) + C #The equation to be graphed 
        
parameters1, covariance1 = curve_fit(model1fit, loads, k) #using curve fit to draw the line for model 1
parameters2, covariance2 = curve_fit(model2fit, loads, k) #using curve fit to draw the line for model 2 

model1_y_fit = model1fit(loads, *parameters1) #This is where I got stuck the most, and going to draw it. Basically this is creating a y value that I can insert into the plot drawing function later by using the parameters calculated above and the loads that will be used as x. The * allows it to be unpacked. 
model2_y_fit = model2fit(loads, *parameters2) #Same thing but for model two. 


plt.plot(loads, k, 'o') #plot the initial data from loads and k 
plt.plot(loads, model1_y_fit, linestyle = '-', label = 'Model1') #Got stuck here as well, needed chatgpt for help here. I passed loads as x and the model_y_fit1 represents the parameters that were passed into the formula then that calculation was used to map this line. 
plt.plot(loads, model2_y_fit, linestyle = '-', label = 'Model2') #Same as above but for model2 instead. 
plt.legend(title = 'Model') #adding a legend so each line can be identified. 

"""Sources include:
    geeksforgeeks.org
    matplotlib documentation
    seaborn plot documentation
    ChatGPT used where specified"""








